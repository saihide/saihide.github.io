<!DOCTYPE html>
<html>
<head>
<title>inside a shard</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h4>fsync sync</h4>
<p><a href="https://en.wikipedia.org/wiki/Sync_(Unix)">fsync/sync</a><br>
sync is a standard system call in the Unix operating system, which commits to disk all data in the kernel filesystem buffers,data which has been scheduled for writing via low-level I/O system calls.Higher-level I/O layers such as stdio may maintain separate buffers of their own.The related system call fsync() commits just the buffered data relating to a specified file descriptor.[1] fdatasync() is also available to write out just the changes made to the data in the file, and not necessarily the file's related metadata.</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/guide/2.x/inside-a-shard.html">inside a shard</a></p>
<h3>inverted index</h3>
<ol>
<li>词汇列表</li>
<li>相似度算法</li>
<li>词汇：大小写，单数复数，同义词</li>
</ol>
<p>每个被索引的字段都有倒排索引<br>
every indexed field in a JSON document has its own inverted index.</p>
<h5>写到磁盘上的inverted index是不可变的。不可变的好处有：</h5>
<ol>
<li>不需要加锁，不用考虑更新时的多线程问题</li>
<li>当index被写入filesystem cache的时候，就一直在cache里了，因为他是不变的，从内存里读取而不用访问磁盘，<br>
提高性能</li>
<li>其他的缓存，比如filter cache,也将是一直有效的，因为index不变，所以其他的缓存也不需要在数据变化是跟着变化</li>
<li>允许数据压缩（Writing a single large inverted index allows the data to be compressed, reducing costly disk I/O and the amount of RAM needed to cache the index）</li>
</ol>
<h5>inverted index不可变的缺点</h5>
<ol>
<li>如果需要让一个新文档可以被搜索，就要重建整个索引，这就限制了一个index的数据容量和索引重建的频率</li>
</ol>
<h5>如何让索引可以更新，任然具有不可变的优势</h5>
<ol>
<li>使用更多的索引</li>
<li>per-segment search的概念，一个片段是一个倒排索引。<br>
一个shard有多个segments</li>
<li>一个分片就是一个 Lucene index，es的一个索引是多个分片的集合</li>
<li>新文档存在缓存里的indexing buffer，每隔一段时间提交一次</li>
</ol>
<h5>indexing buffer提交时做什么</h5>
<ol>
<li>A Lucene index 的内存缓冲区里的新文档准备提交</li>
<li>一个新的片段（a supplementary inverted index）写入到磁</li>
<li>这个new segment加入到commit point，缓冲区清空。<br>
commit point lists all known segments</li>
<li>所有在filesystem cache的数据被写入到文件（持久化）</li>
</ol>
<p>查询时，所有的segment会被轮流查询，</p>
<p>segment是不可变的，没法从老的片段删除或添加文档。所以每个commit point有一个.del文件，<br>
里面记录了哪个片段的哪个文档被删除了，当文档更新时，老版本的文档被表示删除，新版本的文档索引到新segment里</p>
<h4>如果让变化的文档更快的searchable</h4>
<p>瓶颈在于磁盘，提交一个new segment到磁盘需要fsync，fsync是昂贵的。<br>
在es和磁盘直接的是filesystem cache,new segment先写入filesystemcache,之后在写入磁盘。<br>
这个过程叫refresh,分片默认每秒refresh，配置参数refresh_interval，</p>
<pre><code>PUT /my_logs
{
  "settings": {
    "refresh_interval": "30s" 
  }
}
</code></pre>
<p>这个参数可以动态的修改。可以在建立索引时关闭refresh，使用时打开</p>
<pre><code>PUT /my_logs/_settings
{ "refresh_interval": -1 } 

PUT /my_logs/_settings
{ "refresh_interval": "1s" }
</code></pre>
<h4>持久化</h4>
<p>full commit: 将在filesystem cache里的segment写入磁盘，commit point。用在失败后恢复<br>
commit point  lists all known segments,es在启动和重新打卡索引时，通过commit point知道segments属于哪个shards.<br>
当full commit时文件改变了怎么办？</p>
<h5>translog</h5>
<p>translog记录了es发生的每个行为。<br>
文档先添加到in-memory buffer, 再添加到translog.<br>
refresh的时候，buffer清空，translog不变。<br>
The docs in the in-memory buffer are written to a new segment, without an fsync.<br>
The segment is opened to make it visible to search.<br>
The in-memory buffer is cleared.</p>
<h5>full commit</h5>
<p>flush + create new translog<br>
当translog太大或者一定时间后，index is flushed，创建新的translog.</p>
<ol>
<li>Any docs in the in-memory buffer are written to a new segment.</li>
<li>The buffer is cleared.</li>
<li>A commit point is written to disk.</li>
<li>The filesystem cache is flushed with an fsync.</li>
<li>The old translog is delete</li>
</ol>
<p>es启动时，通过last commit point来恢复segments，接着重新执行translog里记录的操作<br>
（When starting up, Elasticsearch will use the last commit point to recover known segments from disk, and will then replay all operations in the translog to add the changes that happened after the last commit.）</p>
<p>translog还被用来做实时的CRUD,当需要通过id retrieve, update, or delete a document,会先检查translog有没有更改，再去segment取文档。这就提供了实时访问最新的文档的方式。</p>
<p>full commit and  truncating the translog  is called flush.分片默认30分钟flush或当translog太大的时候</p>
<h5>translog</h5>
<ol>
<li>index.translog.sync_interval：<br>
How often the translog is fsynced to disk and committed, regardless of write operations. Defaults to 5s.</li>
<li>index.translog.durability：<br>
每次索引，删除，更新，或批量请求之后，是否需要fsync和提交translog，<br>
request:  (default) fsync and commit after every write  request((e.g. index, delete, update, bulk).). In the event of hardware failure, all acknowledged writes will already have been committed to disk<br>
async:   (lose sync_interval's worth of data )fsync and commit in the background every sync_interval. In the event of hardware failure, all acknowledged writes since the last automatic commit will be discarded.</li>
<li>index.translog.fs.type:<br>
Whether to buffer writes to the transaction log in memory or not. This setting accepts the following parameters:<br>
buffered:    (default) Translog writes first go to a 64kB buffer in memory, and are only written to the disk when the buffer is full, or when an fsync is triggered by a write request or the sync_interval.<br>
simple:   Translog writes are written to the file system immediately, without buffering. However, these writes will only be persisted to disk when an fsync and commit is triggered by a write request or the sync_interval.</li>
</ol>
<h4>segment merge</h4>
<p>自动refresh每秒就创建一个segment，每次搜索都会查询每个segment,so,segment越多查询越慢。<br>
es会在后台合并segment,小的合并到大的，这个时候那些已经删除的旧的文档就会从文件系统清除。删除的文档和旧版本的修改过的文档不会复制到新的大segment里<br>
合并结束之后：</p>
<ol>
<li>The new segment is flushed to disk.</li>
<li>A new commit point is written that includes the new segment and excludes the old, smaller 3. segments.</li>
<li>The new segment is opened for search.</li>
<li>The old segments are deleted.</li>
</ol>
<h5>optimize api</h5>
<p>强制合并的api。强制分片的segment数量小于max_num_segments 参数。不应该在活跃的索引上使用。</p>
<pre><code>POST /logstash-2014-10/_optimize?max_num_segments=1 
</code></pre>
<p>optimize 出发的merge是完全没有限制的，他们可能用掉所有的I/O, If you plan on optimizing an index, you should use shard allocation (see Migrate Old Indices) to first move the index to a node where it is safe to run.</p>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
